// this code working on godot 4.3
shader_type spatial;
render_mode specular_schlick_ggx;

const float SMOOTHSTEP_AA = 0.01;
uniform sampler2D surfaceNoise;
uniform sampler2D distortNoise;
uniform sampler2D DEPTH_TEXTURE : hint_depth_texture, filter_linear_mipmap;

uniform float beer_factor = 0.8;

uniform float foam_distance = 0.01;
uniform float foam_max_distance = 0.4;
uniform float foam_min_distance = 0.04;
uniform vec4 foam_color: source_color  = vec4(1.0);

uniform vec2 surface_noise_tiling = vec2(1.0, 4.0);
uniform vec3 surface_noise_scroll = vec3(0.03, 0.03, 0.0);
uniform float surface_noise_cutoff: hint_range(0, 1) = 0.777;
uniform float surface_distortion_amount: hint_range(0, 1) = 0.27;

uniform vec4 _DepthGradientShallow: source_color = vec4(0.325, 0.807, 0.971, 0.725);
uniform vec4 _DepthGradientDeep: source_color = vec4(0.086, 0.407, 1, 0.749);
uniform float _DepthMaxDistance: hint_range(0, 1) = 1.0;
uniform float _DepthFactor = 1.0;

varying vec2 noiseUV;
varying vec2 distortUV;
varying vec3 view_normal;





// Water Noise
uniform float base_height = 10.0;
uniform float wave_amplitude: hint_range(0.0, 100.0) = 2.0;
//uniform float wave_speed: hint_range(-100.0, 100.0) = 1.0;
uniform vec2 wave_direction = vec2(1.0, 0.0);
uniform sampler2D wave_albedo: hint_default_white;
uniform sampler2D wave_height_map: hint_default_white;
uniform sampler2D wave_normal_map: hint_normal;

uniform sampler2D foam_albedo: hint_default_white;


group_uniforms externally_assigned;
uniform float amplitude = 1.0;
uniform float partition_size = 16.0;
uniform int partition_lod_step = 1;
uniform int partition_lod_zero_radius = 1;
uniform vec3 terrain_position;

// Varying variables
varying vec3 world_vertex;

varying vec2 wave_offset;


vec4 alphaBlend(vec4 top, vec4 bottom)
{
	vec3 color = (top.rgb * top.a) + (bottom.rgb * (1.0 - top.a));
	float alpha = top.a + bottom.a * (1.0 - top.a);
	
	return vec4(color, alpha);
}


float get_height(vec3 world_position){
	vec2 uv = (world_position.xz + vec2(0.5)) / float(textureSize(wave_height_map,0).x);
	return base_height + texture(wave_height_map, uv + wave_offset).r * wave_amplitude;
}

vec3 get_normal(vec3 world_position){
	vec2 uv = (world_position.xz + vec2(0.5)) / float(textureSize(wave_height_map,0).x);
	return texture(wave_normal_map, uv).rgb;
}

float true_round(float value){
	return floor(value + 0.5);
}

void vertex() {
	wave_offset = wave_direction * TIME;
	world_vertex = VERTEX + MODEL_MATRIX[3].xyz;

	vec3 terrain_vertex = world_vertex - terrain_position;
	
	float lod = true_round(max(abs(terrain_vertex.x), abs(terrain_vertex.z))/partition_size) * float(partition_lod_step);
	lod = max(0.0, lod - float(partition_lod_zero_radius * partition_lod_step));
	
	float subdivision_size = min(pow(2, lod), partition_size);

	vec3 fraction = fract((VERTEX + partition_size / 2.0) / subdivision_size);

	VERTEX.y = mix(
		mix(
			get_height(world_vertex - vec3(fraction.x * subdivision_size, 0, 0)), 
			get_height(world_vertex + vec3((1.0-fraction.x) * subdivision_size, 0, 0)), 
			fraction.x
		), 
		mix(
			get_height(world_vertex - vec3(0, 0, fraction.z * subdivision_size)), 
			get_height(world_vertex + vec3(0, 0, (1.0-fraction.z) * subdivision_size)), 
			fraction.z
		), 
		ceil(fraction.z)
	);

	world_vertex.y = VERTEX.y;
	
	view_normal = (MODELVIEW_MATRIX * vec4(NORMAL, 0.0)).xyz;
	noiseUV = UV * surface_noise_tiling;
	distortUV = UV;
}

void fragment() {
	float depthVal = texture(DEPTH_TEXTURE, SCREEN_UV).r;
	float depth = PROJECTION_MATRIX[3][2] / (depthVal + PROJECTION_MATRIX[2][2]);
	depth = depth + VERTEX.z;
	depth = exp(-depth * beer_factor);
	depth = 1.0 - depth;
	
	// Still unsure how to get properly the NORMAL from the camera
	// This was generated by ChatGPT xD
    vec4 view_pos = INV_PROJECTION_MATRIX * vec4(SCREEN_UV * 2.0 - 1.0, depthVal, 1.0);
    view_pos /= view_pos.w;
    vec3 existingNormal = normalize(cross( dFdx(view_pos.xyz), dFdy(view_pos.xyz)));

	float normalDot = clamp(dot(existingNormal.xyz, view_normal), 0.0, 1.0);
	float foamDistance = mix(foam_max_distance, foam_min_distance, normalDot);
	
	float foamDepth = clamp(depth / foamDistance, 0.0, 1.0);
	float surfaceNoiseCutoff = foamDepth * surface_noise_cutoff;
	
	vec4 distortNoiseSample = texture(distortNoise, distortUV);
	vec2 distortAmount = (distortNoiseSample.xy * 2.0 -1.0) * surface_distortion_amount;
	
	vec2 noise_uv = vec2(
		(noiseUV.x + TIME * surface_noise_scroll.x) + distortAmount.x , 
		(noiseUV.y + TIME * surface_noise_scroll.y + distortAmount.y)
	);
	float surfaceNoiseSample = texture(surfaceNoise, noise_uv).r;
	float surfaceNoiseAmount = smoothstep(surfaceNoiseCutoff - SMOOTHSTEP_AA, surfaceNoiseCutoff + SMOOTHSTEP_AA, surfaceNoiseSample);
	
	float waterDepth = clamp(depth / _DepthMaxDistance, 0.0, 1.0) * _DepthFactor;
	vec4 waterColor = mix(_DepthGradientShallow, _DepthGradientDeep, waterDepth);

	vec4 surfaceNoiseColor = foam_color;
    surfaceNoiseColor.a *= surfaceNoiseAmount;
	vec4 color = alphaBlend(surfaceNoiseColor, waterColor);
	
    ALBEDO = color.rgb;
	ALPHA = color.a;
	//NORMAL_MAP = get_normal(world_vertex);
}

//void fragment() {
	////discard;
	////float time = TIME * speed;
	////
	////vec3 n1 = texture(noise1, UV + time).rgb;
	////
	////vec3 n2 = texture(noise2, UV - time * 0.2).rgb;
	////
	////vec2 uv_movement = UV * 4.0;
	////uv_movement += TIME * speed * 4.0;
	////
	//float z_depth = rim(texture(DEPTH_TEXTURE, SCREEN_UV).x);
	//
	//float z_pos = rim(FRAGCOORD.z);
	//
	//float diff = z_depth - z_pos;
	//
	//// depth-fade
	//float z_depth_fade = calc_depth_fade(texture(DEPTH_TEXTURE, SCREEN_UV).x, PROJECTION_MATRIX, FRAGCOORD, beer_law_factor, _distance, VERTEX);
	//
	//float z_fade = rim(FRAGCOORD.z);
	//
	//float fade_diff = z_depth_fade - z_fade;
	//
	//vec4 gradientcolor = mix(color, deep_water, z_depth_fade);
	//
	////If enable this line 119-120, it can caused bug for edge effect
	////vec2 displacement = vec2(sum * 0.01);
	////diff += displacement.x * 15.0;
	////
	//vec4 depth_color_adj = mix(edge_color, gradientcolor, step(edge_scale, diff));
	//
	//vec4 alpha = texture(SCREEN_TEXTURE, SCREEN_UV);
//
	//// Calculate Fresnel
	//float fresnel = fresnel(2.0, NORMAL, VIEW);
//
	////vec4 surface_color = mix(color, deep_water, fresnel);
	//
	//ALBEDO = mix(alpha.rgb, gradientcolor.rgb, gradientcolor.a);
	//
	//float depth = texture(DEPTH_TEXTURE, SCREEN_UV).r;
	//
	//vec4 upos = INV_PROJECTION_MATRIX * vec4(SCREEN_UV * 2.0 - 1.0, depth, 1.0);
	//
	//vec3 pixel_position = upos.xyz / upos.w;
    //
	//// Adjust the edge foam calculation to include edge_scale
	//if (VERTEX.z < pixel_position.z + 0.05 + edge_scale) {
  		//ALBEDO = vec3(edge_color.rgb);
	//}
	//
	////NORMAL_MAP = texture(normalmap, uv_movement).rgb;
	////
	//NORMAL_MAP = get_normal(world_vertex);
	//METALLIC = metallic;
//
	//ROUGHNESS = roughness;
//}